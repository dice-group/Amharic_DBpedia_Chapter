{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"../../services/highlight.service\";\nimport * as i2 from \"@angular/material/list\";\nimport * as i3 from \"@angular/material/icon\";\nexport let RunningDIEFDocumentationComponent = /*#__PURE__*/(() => {\n  class RunningDIEFDocumentationComponent {\n    constructor(highLightService, renderer) {\n      this.highLightService = highLightService;\n      this.renderer = renderer;\n      this._styleElement = this.renderer.createElement('link');\n      this._scriptElement = this.renderer.createElement('script');\n      this._highlighted = false;\n    }\n    ngOnInit() {\n      this._loadScript('../../../assets/scripts/prism.js');\n      this._styleElement.rel = 'stylesheet';\n      this._styleElement.href = \"../../../assets/css/prism.css\";\n      this.renderer.appendChild(document.head, this._styleElement);\n    }\n    ngAfterViewInit() {\n      if (!this._highlighted) {\n        this.highLightService.highlightAll();\n        this._highlighted = true;\n      }\n    }\n    ngOnDestroy() {\n      if (this._styleElement) {\n        this.renderer.removeChild(document.head, this._styleElement);\n      }\n    }\n    _loadScript(src) {\n      this._scriptElement = this.renderer.createElement('script');\n      this._scriptElement.src = src;\n      this._scriptElement.type = 'text/javascript';\n      this._scriptElement.async = true;\n      this.renderer.appendChild(document.body, this._scriptElement);\n    }\n    static {\n      this.ɵfac = function RunningDIEFDocumentationComponent_Factory(t) {\n        return new (t || RunningDIEFDocumentationComponent)(i0.ɵɵdirectiveInject(i1.HighlightService), i0.ɵɵdirectiveInject(i0.Renderer2));\n      };\n    }\n    static {\n      this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n        type: RunningDIEFDocumentationComponent,\n        selectors: [[\"app-running-dief-extractor-documentation\"]],\n        decls: 279,\n        vars: 0,\n        consts: [[1, \"documentation-content-container\"], [1, \"title\"], [1, \"subtitle\"], [1, \"documentation-content\"], [1, \"paragraph\"], [1, \"sub-section-title\"], [\"src\", \"../../../assets/img/The-Process-of-DBpedia-Extraction-Framework.png\", \"alt\", \"The process of DBpedia Extraction Framework\"], [\"href\", \"https://github.com/dbpedia/extraction-framework\", \"target\", \"_blank\", \"rel\", \"noopener noreferrer\"], [\"src\", \"../../../assets/img/Overview-of-DBpedia-extraction-framework.png\", \"alt\", \"Over view of the DBpedia extraction framework\"], [1, \"sub-sub-section-title\"], [1, \"code-snippet-container\"], [1, \"code-snippet-header\"], [1, \"language-sparql\"], [1, \"subsection-title\"], [1, \"highlight-language-keyword\"], [\"href\", \"https://dbpedia.org/ontology/Film\", \"target\", \"_blank\", \"rel\", \"noopener noreferrer\"], [\"href\", \"http://dbpedia.org/ontology/Film\", \"target\", \"_blank\", \"rel\", \"noopener noreferrer\"], [\"href\", \"http://xmlns.com/foaf/0.1/name\", \"target\", \"_blank\", \"rel\", \"noopener noreferrer\"], [1, \"highlight-language-clause\"], [1, \"paragraph\", \"closing-remarks\"], [1, \"resources\"], [1, \"footer\"], [1, \"author\"], [1, \"date\"]],\n        template: function RunningDIEFDocumentationComponent_Template(rf, ctx) {\n          if (rf & 1) {\n            i0.ɵɵelementStart(0, \"div\", 0)(1, \"h1\", 1);\n            i0.ɵɵtext(2, \"Running the dief framework\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelement(3, \"h2\", 2);\n            i0.ɵɵelementStart(4, \"div\", 3)(5, \"div\", 4)(6, \"h3\", 5);\n            i0.ɵɵtext(7, \"Getting Started\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(8, \"p\");\n            i0.ɵɵtext(9, \" The DBpedia Extraction Framework is an open-source tool used to extract structured information from Wikipedia. It converts the unstructured content of Wikipedia into RDF data, making it accessible for semantic web applications. This framework plays a crucial role in generating and maintaining the DBpedia knowledge base, which is widely used for research and data integration. The image below summrizes the the overall extraction framework. \");\n            i0.ɵɵelement(10, \"img\", 6);\n            i0.ɵɵtext(11, \" If you are interested in learning how the DIEF in works in depth you can view the documentation here you can also view or download the framework \");\n            i0.ɵɵelementStart(12, \"a\", 7);\n            i0.ɵɵtext(13, \"here\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(14, \". In this guide we will focus on running and extending the framework for Amharic. \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(15, \"div\", 4)(16, \"h2\", 2);\n            i0.ɵɵtext(17, \"Running the framework\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(18, \"h3\", 5);\n            i0.ɵɵtext(19, \"Extraction process\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(20, \"p\");\n            i0.ɵɵtext(21, \" Running the extraction framework is a relatively complex task which is in details documented in the advanced QuickStart guide. To run the extraction process same as the DBpedia core team does, you can do using the MARVIN release bot. The MARVIN bot automates the overall extraction process, from downloading the ontology, mappings and Wikipedia dumps, to extraction and post-processing the data. Extraction generally could be of two types Generic and mapping based. Generic extracors use herustics to extract data while mapping based extractors uses manually curated mappings. you can view these mappings here. The extraction process generally involves parsing data and extracting information from wikipedia pages to make them available for query. \");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelement(22, \"img\", 8);\n            i0.ɵɵelementStart(23, \"p\");\n            i0.ɵɵtext(24, \"In this guide we will focus on running the extraction framework specifically for Amharic.\");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(25, \"div\", 4)(26, \"h4\", 9);\n            i0.ɵɵtext(27, \"Getting Sources files\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelement(28, \"p\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(29, \"div\", 10);\n            i0.ɵɵelement(30, \"div\", 11);\n            i0.ɵɵelementStart(31, \"pre\")(32, \"code\", 12);\n            i0.ɵɵtext(33, \"\\n          SELECT ?s ?p ?o \");\n            i0.ɵɵelement(34, \"br\");\n            i0.ɵɵtext(35, \"\\n          WHERE { \");\n            i0.ɵɵelement(36, \"br\");\n            i0.ɵɵtext(37, \"\\n          ?s ?p ?o . \");\n            i0.ɵɵelement(38, \"br\");\n            i0.ɵɵtext(39, \"\\n          }\\n        \");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(40, \"\\n        \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(41, \"div\", 4)(42, \"p\");\n            i0.ɵɵtext(43, \" In this query, ?s, ?p, and ?o represent the subject, predicate, and object of every triple in the dataset. When this query runs, it returns a list of all the triples, essentially giving you a snapshot of the entire dataset. It\\u2019s a powerful way to start exploring your data and understanding the structure of the information you're working with. \");\n            i0.ɵɵelement(44, \"br\")(45, \"br\");\n            i0.ɵɵtext(46, \" In the following sections of this guideline, we will explain the basics of writing a SPARQL query. We will use a simple scenario of searching the DBpedia database for information about movies. \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(47, \"div\", 4)(48, \"h3\", 13);\n            i0.ɵɵtext(49, \"SELECT, WHERE and LIMIT\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(50, \"p\");\n            i0.ɵɵtext(51, \" In SPARQL, the \");\n            i0.ɵɵelementStart(52, \"em\", 14);\n            i0.ɵɵtext(53, \"SELECT\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(54, \" clause is where you define the specific pieces of data you want to pull from your dataset. Think of it as telling the query exactly what information you're looking for and inorder to actually find the data you're interested in, you'll use the \");\n            i0.ɵɵelementStart(55, \"em\", 14);\n            i0.ɵɵtext(56, \"WHERE\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(57, \" clause. This is where you set the conditions, or patterns, that your data needs to match. It's like giving your query a set of instructions: \\\"Find me movies, but only those that match these specific criteria.\\\" The following code snippet shows a query to retrieve a list of movies and their titles from DBpedia database. \");\n            i0.ɵɵelement(58, \"br\");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(59, \"div\", 10);\n            i0.ɵɵelement(60, \"div\", 11);\n            i0.ɵɵelementStart(61, \"pre\")(62, \"code\", 12);\n            i0.ɵɵtext(63, \"\\n          SELECT ?movie ?title \");\n            i0.ɵɵelement(64, \"br\");\n            i0.ɵɵtext(65, \"\\n          WHERE {\\n           ?movie a <http://dbpedia.org/ontology/Film> ;\\n          <http://xmlns.com/foaf/0.1/name> ?title . \\n           }\\n          LIMIT 10\\n      \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(66, \"div\", 4)(67, \"p\");\n            i0.ɵɵtext(68, \" In the above example, we are using the keyword \");\n            i0.ɵɵelementStart(69, \"em\", 14);\n            i0.ɵɵtext(70, \"SELECT\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(71, \" to specify which variables we want to retrieve the movie itself (?movie) and its title (?title). \");\n            i0.ɵɵelement(72, \"br\")(73, \"br\");\n            i0.ɵɵtext(74, \" The keyword \");\n            i0.ɵɵelementStart(75, \"em\", 14);\n            i0.ɵɵtext(76, \"WHERE\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(77, \" is used to specify the conditions for matching data. Here, it specifies that: \");\n            i0.ɵɵelementStart(78, \"mat-list\")(79, \"mat-list-item\")(80, \"p\");\n            i0.ɵɵtext(81, \" 1. `?movie` should be an instance of \");\n            i0.ɵɵelementStart(82, \"a\", 15);\n            i0.ɵɵtext(83, \"http://dbpedia.org/ontology/Film\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(84, \", which is a DBpedia ontology class that represents a movie. \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(85, \"mat-list-item\")(86, \"p\");\n            i0.ɵɵtext(87, \" 2. `?movie` should have a property called `foaf:name`, which holds the movie\\u2019s title. \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(88, \"em\", 14);\n            i0.ɵɵtext(89, \"LIMIT\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(90, \" keyword is used to truncate the list of returned data and keep only the first 10 results. This is very handy when you are dealing with a large dataset but you are only interested in a sample pool. By setting a limit, you can easily achieve this. \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(91, \"div\", 4)(92, \"p\");\n            i0.ɵɵtext(93, \" We can also retrieve additional properties, as long as those properties are present in the ontology class, by binding more variables. Below is a code snippet to retrieve the runtime and release date, in addition to the name of each movie. \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(94, \"div\", 10);\n            i0.ɵɵelement(95, \"div\", 11);\n            i0.ɵɵelementStart(96, \"pre\")(97, \"code\", 12);\n            i0.ɵɵtext(98, \"\\n          SELECT ?movie ?name ?runtime ?releaseDate \");\n            i0.ɵɵelement(99, \"br\");\n            i0.ɵɵtext(100, \"\\n          WHERE {\\n            ?movie a <http://dbpedia.org/ontology/Film> ;\\n                   <http://xmlns.com/foaf/0.1/name> ?name ;\\n                   <http://dbpedia.org/ontology/runtime> ?runtime ;\\n                   <http://dbpedia.org/ontology/releaseDate> ?releaseDate . \\n          }\\n          LIMIT 10\\n      \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(101, \"div\", 4)(102, \"h3\", 5);\n            i0.ɵɵtext(103, \" Internationalized Resource Identifiers - IRIs \");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(104, \"p\");\n            i0.ɵɵtext(105, \" In SPARQL queries, URLs (Uniform Resource Locators) and IRIs (Internationalized Resource Identifiers) are important for identifying resources and properties. They serve as unique identifiers that allow you to precisely specify the data you want to query. Each URL or IRI points to a specific resource or property within a dataset - DBpedia, for example, has its own set of resources and properties. Using IRIs eliminates confusion about what you\\u2019re querying and provides clear references that are understood universally. \");\n            i0.ɵɵelement(106, \"br\")(107, \"br\");\n            i0.ɵɵtext(108, \" For instance, in our previous query example: \");\n            i0.ɵɵelementStart(109, \"mat-list\")(110, \"mat-list-item\")(111, \"p\");\n            i0.ɵɵtext(112, \" -> The URL \");\n            i0.ɵɵelementStart(113, \"a\", 16);\n            i0.ɵɵtext(114, \" `http://dbpedia.org/ontology/Film` \");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(115, \" identifies the Film class within the DBpedia ontology, specifying that we are interested in resources categorized as movies. \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(116, \"mat-list-item\")(117, \"p\");\n            i0.ɵɵtext(118, \" -> The URL \");\n            i0.ɵɵelementStart(119, \"a\", 17);\n            i0.ɵɵtext(120, \"`http://xmlns.com/foaf/0.1/name`\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(121, \" identifies the name property, which holds the title of each movie. \");\n            i0.ɵɵelementEnd()()()();\n            i0.ɵɵelementStart(122, \"div\", 4)(123, \"p\");\n            i0.ɵɵtext(124, \" These URLs (or IRIs) are essential because they uniquely define what we mean by \\\"Film\\\" and \\\"name\\\" in the context of the DBpedia dataset. \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(125, \"div\", 10);\n            i0.ɵɵelement(126, \"div\", 11);\n            i0.ɵɵelementStart(127, \"pre\")(128, \"code\", 12);\n            i0.ɵɵtext(129, \"\\n          PREFIX dbo: <http://dbpedia.org/ontology/> \");\n            i0.ɵɵelement(130, \"br\");\n            i0.ɵɵtext(131, \" \\n          PREFIX dbp: <http://dbpedia.org/property> \");\n            i0.ɵɵelement(132, \"br\");\n            i0.ɵɵtext(133, \"\\n          SELECT ?movie ?name ?releaseDate \");\n            i0.ɵɵelement(134, \"br\");\n            i0.ɵɵtext(135, \"\\n          WHERE { \\n          ?movie a dbo:Film ; \\n          dbp:name ?name ; \\n          dbo:releaseDate\\n          ?releaseDate .\\n           } \\n          LIMIT 10\\n        \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(136, \"div\", 4)(137, \"h3\", 13);\n            i0.ɵɵtext(138, \"Prefixes\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(139, \"p\");\n            i0.ɵɵtext(140, \" As you start writing SPARQL queries, you\\u2019ll notice that many of the resources and properties have long, complex IRIs. Constantly typing out these lengthy IRIs can be cumbersome. That\\u2019s where prefixes come in. \");\n            i0.ɵɵelement(141, \"br\")(142, \"br\");\n            i0.ɵɵtext(143, \" Prefixes are shorthand notations that allow you to reference long IRIs with shorter, more readable terms. By defining a prefix at the beginning of your SPARQL query, you create an alias for a specific IRI. This approach helps in making your queries cleaner and easier to read. To create a prefix, you need to identify the resource IRI that you will use. Specific properties from that IRI are referenced using the alias you define, so you only need to provide the part of the resource path after the prefix. The syntax is the keyword PREFIX, followed by an alias name, a colon, and the resource URL. \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(144, \"div\", 10)(145, \"div\", 11)(146, \"a\")(147, \"mat-icon\");\n            i0.ɵɵtext(148, \"content_copy\");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(149, \"pre\")(150, \"code\", 12);\n            i0.ɵɵtext(151, \"\\n            PREFIX dbo: <http://dbpedia.org/ontology/>\\n          \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(152, \"div\", 4)(153, \"p\");\n            i0.ɵɵtext(154, \" Now let\\u2019s take the previous example where we queried for the name, release date, and runtime of movies, and define prefixes to tidy up the query: \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(155, \"div\", 10)(156, \"div\", 11)(157, \"a\")(158, \"mat-icon\");\n            i0.ɵɵtext(159, \"content_copy\");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(160, \"a\")(161, \"mat-icon\");\n            i0.ɵɵtext(162, \"open_in_new\");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(163, \"pre\")(164, \"code\", 12);\n            i0.ɵɵtext(165, \"\\n            PREFIX dbo: <http://dbpedia.org/ontology/> \");\n            i0.ɵɵelement(166, \"br\");\n            i0.ɵɵtext(167, \"\\n            PREFIX foaf: <http://xmlns.com/foaf/0.1/> \");\n            i0.ɵɵelement(168, \"br\");\n            i0.ɵɵtext(169, \"\\n            SELECT ?movie ?name ?runtime ?releaseDate \");\n            i0.ɵɵelement(170, \"br\");\n            i0.ɵɵtext(171, \"\\n            WHERE {\\n              ?movie a dbo:Film ; \");\n            i0.ɵɵelement(172, \"br\");\n            i0.ɵɵtext(173, \"\\n                     foaf:name ?name ; \");\n            i0.ɵɵelement(174, \"br\");\n            i0.ɵɵtext(175, \"\\n                     dbo:runtime ?runtime ; \");\n            i0.ɵɵelement(176, \"br\");\n            i0.ɵɵtext(177, \"\\n                     dbo:releaseDate ?releaseDate . \");\n            i0.ɵɵelement(178, \"br\");\n            i0.ɵɵtext(179, \"\\n            }\\n            LIMIT 10\\n        \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(180, \"div\", 4)(181, \"h3\", 5);\n            i0.ɵɵtext(182, \"Filters\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(183, \"p\");\n            i0.ɵɵtext(184, \" In SPARQL queries, filters are used to refine and constrain the results based on specific conditions. They help in selecting only those data entries that meet certain criteria, narrowing down the dataset to only the most pertinent information. \");\n            i0.ɵɵelement(185, \"br\")(186, \"br\");\n            i0.ɵɵtext(187, \" Use filters when you need to enforce specific conditions on your data, such as retrieving only movies released after a certain year or only movies with a runtime longer than a specific duration. \");\n            i0.ɵɵelement(188, \"br\")(189, \"br\");\n            i0.ɵɵtext(190, \" Here\\u2019s an example of how you might use a FILTER in a SPARQL query to retrieve only movies released after 2000 and with a runtime of less than an hour and a half: \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(191, \"div\", 10);\n            i0.ɵɵelement(192, \"div\", 11);\n            i0.ɵɵelementStart(193, \"pre\")(194, \"code\", 12);\n            i0.ɵɵtext(195, \"\\n          PREFIX dbo: <http://dbpedia.org/ontology/> \");\n            i0.ɵɵelement(196, \"br\");\n            i0.ɵɵtext(197, \"\\n          PREFIX foaf: <http://xmlns.com/foaf/0.1/> \");\n            i0.ɵɵelement(198, \"br\")(199, \"br\");\n            i0.ɵɵtext(200, \"\\n          SELECT ?movie ?name ?releaseDate ?runtime \");\n            i0.ɵɵelement(201, \"br\");\n            i0.ɵɵtext(202, \"\\n          WHERE {\\n            ?movie a dbo:Film ; \");\n            i0.ɵɵelement(203, \"br\");\n            i0.ɵɵtext(204, \"\\n                   foaf:name ?name ; \");\n            i0.ɵɵelement(205, \"br\");\n            i0.ɵɵtext(206, \"\\n                   dbo:releaseDate ?releaseDate ; \");\n            i0.ɵɵelement(207, \"br\");\n            i0.ɵɵtext(208, \"\\n                   dbo:runtime ?runtime . \");\n            i0.ɵɵelement(209, \"br\");\n            i0.ɵɵtext(210, \"\\n            FILTER (YEAR(?releaseDate) > 2000 \\n                     && ?runtime < \\\"PT1H30M\\\"^^xsd:duration) \");\n            i0.ɵɵelement(211, \"br\");\n            i0.ɵɵtext(212, \"\\n          }\\n          LIMIT 10\\n      \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(213, \"div\", 4)(214, \"p\");\n            i0.ɵɵtext(215, \" The \");\n            i0.ɵɵelementStart(216, \"em\", 14);\n            i0.ɵɵtext(217, \"WHERE\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(218, \" clause is used to define the pattern of triples that your query will match in the dataset. It specifies the conditions for the data relationships and structure. On the otherhand, The \");\n            i0.ɵɵelementStart(219, \"em\", 14);\n            i0.ɵɵtext(220, \"FILTER\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(221, \" clause is applied after the WHERE clause to impose additional constraints on the results. It refines the results by evaluating expressions based on the variables returned by the WHERE clause. \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(222, \"div\", 4)(223, \"h3\", 5);\n            i0.ɵɵtext(224, \"Order By\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(225, \"p\")(226, \"em\", 18);\n            i0.ɵɵtext(227, \"ORDER BY\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(228, \" is a straightforward keyword in SPARQL that helps to sort query results based on specified conditions. In our example, let's say we want to order the movies by their release date in descending order, so the most recent movies appear at the top. \");\n            i0.ɵɵelement(229, \"br\")(230, \"br\");\n            i0.ɵɵtext(231, \" Here's how you would modify the query to include the em.highlight-language-clauseORDER BY clause:\");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(232, \"div\", 10);\n            i0.ɵɵelement(233, \"div\", 11);\n            i0.ɵɵelementStart(234, \"pre\")(235, \"code\", 12);\n            i0.ɵɵtext(236, \"\\n          PREFIX dbo: <http://dbpedia.org/ontology/> \");\n            i0.ɵɵelement(237, \"br\");\n            i0.ɵɵtext(238, \"\\n          PREFIX foaf: <http://xmlns.com/foaf/0.1/> \");\n            i0.ɵɵelement(239, \"br\");\n            i0.ɵɵtext(240, \"\\n          SELECT ?movie ?name ?releaseDate \");\n            i0.ɵɵelement(241, \"br\");\n            i0.ɵɵtext(242, \"\\n          WHERE {\\n            ?movie a dbo:Film ; \");\n            i0.ɵɵelement(243, \"br\");\n            i0.ɵɵtext(244, \"\\n                   foaf:name ?name ; \");\n            i0.ɵɵelement(245, \"br\");\n            i0.ɵɵtext(246, \"\\n                   dbo:releaseDate ?releaseDate . \");\n            i0.ɵɵelement(247, \"br\");\n            i0.ɵɵtext(248, \"\\n          }\\n          ORDER BY DESC(?releaseDate) \");\n            i0.ɵɵelement(249, \"br\");\n            i0.ɵɵtext(250, \"\\n          LIMIT 10\\n      \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(251, \"div\", 19)(252, \"p\");\n            i0.ɵɵtext(253, \" By understanding the basics of querying with SPARQL you now have the foundation needed to explore and interact with RDF data effectively. \");\n            i0.ɵɵelement(254, \"br\")(255, \"br\");\n            i0.ɵɵtext(256, \" SPARQL provides powerful tools to retrieve and manipulate data from diverse datasets, making it an invaluable skill for working with the Semantic Web. As you continue to practice and experiment with different queries, you\\u2019ll discover even more advanced techniques and functionalities. \");\n            i0.ɵɵelement(257, \"br\")(258, \"br\");\n            i0.ɵɵtext(259, \" If you\\u2019re eager to dive deeper, we\\u2019ve compiled additional resources for further reading and exploration. Happy querying! \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(260, \"div\", 20)(261, \"h3\", 5);\n            i0.ɵɵtext(262, \"Additional Resources\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(263, \"p\");\n            i0.ɵɵtext(264, \"For further reading, below are some resources to get you started:\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(265, \"mat-list\")(266, \"mat-list-item\");\n            i0.ɵɵtext(267, \"-> DuCharme, B. (2013). Learning SPARQL: Querying and updating with SPARQL 1.1. O'Reilly Media. \");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelement(268, \"mat-list-item\");\n            i0.ɵɵelementStart(269, \"mat-list-item\");\n            i0.ɵɵtext(270, \"W3C Recommendation 21 March 2013https://www.w3.org/TR/sparql11-query/ \");\n            i0.ɵɵelementEnd()()()();\n            i0.ɵɵelementStart(271, \"div\", 21);\n            i0.ɵɵelement(272, \"hr\");\n            i0.ɵɵelementStart(273, \"p\");\n            i0.ɵɵtext(274, \"Images courtesy of: John Doe on Unsplash, Jane Smith on Pixabay\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(275, \"p\", 22);\n            i0.ɵɵtext(276, \"Author: Meti Bayissa\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(277, \"p\", 23);\n            i0.ɵɵtext(278, \"August, 2024\");\n            i0.ɵɵelementEnd()()();\n          }\n        },\n        dependencies: [i2.MatList, i2.MatListItem, i3.MatIcon],\n        styles: [\".documentation-content-container[_ngcontent-%COMP%]{margin:7% 10%}.documentation-content-container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{text-align:center;font-size:2.5rem;font-weight:700;color:#073144;text-transform:capitalize}.documentation-content-container[_ngcontent-%COMP%]   .sub-section-title[_ngcontent-%COMP%]{font-size:1.4rem;text-transform:capitalize;margin-bottom:1rem}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .paragraph[_ngcontent-%COMP%]{text-align:justify;line-height:25px;font-size:1.1rem}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .paragraph[_ngcontent-%COMP%]   .highlight-language-keyword[_ngcontent-%COMP%]{color:#e80b76;font-weight:500}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .code-snippet-container[_ngcontent-%COMP%]{padding:0 1.5rem;margin:2% 5%}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .code-snippet-header[_ngcontent-%COMP%]{background-color:#eecd62aa;display:flex;height:1.2rem;justify-content:flex-end;gap:15px;color:#0c0900;padding:.5rem}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .language-sparql[_ngcontent-%COMP%]{margin:0!important;padding:0!important}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .closing-remarks[_ngcontent-%COMP%]{margin-top:7%}.documentation-content-container[_ngcontent-%COMP%]   .footer[_ngcontent-%COMP%]{font-style:italic;color:gray;margin-top:9%;text-align:center}.documentation-content-container[_ngcontent-%COMP%]   mat-list-item[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{word-wrap:break-word;white-space:pre-wrap}@media (max-width: 768px){.documentation-content-container[_ngcontent-%COMP%]{margin:5% 8%}.documentation-content-container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{font-size:2rem}.documentation-content-container[_ngcontent-%COMP%]   .sub-section-title[_ngcontent-%COMP%]{font-size:1.3rem}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .paragraph[_ngcontent-%COMP%]{font-size:1rem;line-height:22px}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .code-snippet-container[_ngcontent-%COMP%]{margin:2%}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .code-snippet-header[_ngcontent-%COMP%]{height:auto;padding:.3rem}.documentation-content-container[_ngcontent-%COMP%]   .footer[_ngcontent-%COMP%]{margin-top:7%}}@media (max-width: 480px){.documentation-content-container[_ngcontent-%COMP%]{margin:5%}.documentation-content-container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{font-size:1.8rem}.documentation-content-container[_ngcontent-%COMP%]   .sub-section-title[_ngcontent-%COMP%]{font-size:1.2rem}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .paragraph[_ngcontent-%COMP%]{font-size:.95rem;line-height:20px}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .code-snippet-container[_ngcontent-%COMP%]{margin:2% 1%;padding:0 1rem}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .code-snippet-header[_ngcontent-%COMP%]{font-size:.9rem;padding:.2rem}.documentation-content-container[_ngcontent-%COMP%]   .footer[_ngcontent-%COMP%]{font-size:.9rem;margin-top:6%}}\"]\n      });\n    }\n  }\n  return RunningDIEFDocumentationComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}