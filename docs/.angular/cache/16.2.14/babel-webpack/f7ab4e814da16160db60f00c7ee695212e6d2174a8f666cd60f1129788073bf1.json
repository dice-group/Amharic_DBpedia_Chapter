{"ast":null,"code":"import * as i0 from \"@angular/core\";\nimport * as i1 from \"../../services/highlight.service\";\nimport * as i2 from \"@angular/material/list\";\nimport * as i3 from \"@angular/material/icon\";\nexport let SparqlForBeginnersDocumentationComponent = /*#__PURE__*/(() => {\n  class SparqlForBeginnersDocumentationComponent {\n    constructor(highLightService, renderer) {\n      this.highLightService = highLightService;\n      this.renderer = renderer;\n      this._styleElement = this.renderer.createElement('link');\n      this._scriptElement = this.renderer.createElement('script');\n      this._highlighted = false;\n    }\n    ngOnInit() {\n      this._loadScript('../../../assets/scripts/prism.js');\n      this._styleElement.rel = 'stylesheet';\n      this._styleElement.href = \"../../../assets/css/prism.css\";\n      this.renderer.appendChild(document.head, this._styleElement);\n    }\n    ngAfterViewInit() {\n      if (!this._highlighted) {\n        this.highLightService.highlightAll();\n        this._highlighted = true;\n      }\n    }\n    ngOnDestroy() {\n      if (this._styleElement) {\n        this.renderer.removeChild(document.head, this._styleElement);\n      }\n    }\n    _loadScript(src) {\n      this._scriptElement = this.renderer.createElement('script');\n      this._scriptElement.src = src;\n      this._scriptElement.type = 'text/javascript';\n      this._scriptElement.async = true;\n      this.renderer.appendChild(document.body, this._scriptElement);\n    }\n    static {\n      this.ɵfac = function SparqlForBeginnersDocumentationComponent_Factory(t) {\n        return new (t || SparqlForBeginnersDocumentationComponent)(i0.ɵɵdirectiveInject(i1.HighlightService), i0.ɵɵdirectiveInject(i0.Renderer2));\n      };\n    }\n    static {\n      this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n        type: SparqlForBeginnersDocumentationComponent,\n        selectors: [[\"app-sparql-for-beginners-documentation\"]],\n        decls: 267,\n        vars: 0,\n        consts: [[1, \"documentation-content-container\"], [1, \"title\"], [1, \"subtitle\"], [1, \"documentation-content\"], [1, \"paragraph\"], [1, \"sub-section-title\"], [\"href\", \"https://en.wikipedia.org/wiki/Semantic_triple\", \"target\", \"_blank\", \"rel\", \"noopener noreferrer\"], [1, \"code-snippet-container\"], [1, \"code-snippet-header\"], [1, \"language-sparql\"], [1, \"subsection-title\"], [1, \"highlight-language-keyword\"], [\"href\", \"https://dbpedia.org/ontology/Film\", \"target\", \"_blank\", \"rel\", \"noopener noreferrer\"], [\"href\", \"http://dbpedia.org/ontology/Film\", \"target\", \"_blank\", \"rel\", \"noopener noreferrer\"], [\"href\", \"http://xmlns.com/foaf/0.1/name\", \"target\", \"_blank\", \"rel\", \"noopener noreferrer\"], [1, \"highlight-language-clause\"], [1, \"paragraph\", \"closing-remarks\"], [1, \"resources\"], [1, \"footer\"], [1, \"author\"], [1, \"date\"]],\n        template: function SparqlForBeginnersDocumentationComponent_Template(rf, ctx) {\n          if (rf & 1) {\n            i0.ɵɵelementStart(0, \"div\", 0)(1, \"h1\", 1);\n            i0.ɵɵtext(2, \"Querying using SPARQL for Beginners\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelement(3, \"h2\", 2);\n            i0.ɵɵelementStart(4, \"div\", 3)(5, \"div\", 4)(6, \"h3\", 5);\n            i0.ɵɵtext(7, \"Getting Started\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(8, \"p\");\n            i0.ɵɵtext(9, \" Before diving into the details of how to structure a SPARQL query, it\\u2019s important to understand the basics of how SPARQL works. At its core, SPARQL is all about querying data that\\u2019s structured in triples. A \");\n            i0.ɵɵelementStart(10, \"a\", 6);\n            i0.ɵɵtext(11, \"triple\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(12, \" is the most fundamental unit of data in RDF (Resource Description Framework), and it consists of three parts: the subject, predicate, and object. \");\n            i0.ɵɵelement(13, \"br\")(14, \"br\");\n            i0.ɵɵtext(15, \"You can think of triples like a simple sentence. The subject is what the sentence is about, the predicate is the characteristic or property of the subject, and the object is the value of that property. For example, in the triple <Movie1> <hasTitle> \\\"Titanic\\\", <Movie1> is the subject, <hasTitle> is the predicate, and \\\"Titanic\\\" is the object. In SPARQL, variables are used to stand in for the parts of these triples that you're interested in. \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(16, \"div\", 4)(17, \"h3\", 5);\n            i0.ɵɵtext(18, \"Variables\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(19, \" Variables in SPARQL are denoted by a question mark (?) before the name, like ?movie, ?title, or ?releaseDate. These variables allow you to ask the database for any triples that match certain patterns. For instance, if you wanted to retrieve all triples in a dataset, you could write a simple query using variables for the subject, predicate, and object, like so: \");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(20, \"div\", 7);\n            i0.ɵɵelement(21, \"div\", 8);\n            i0.ɵɵelementStart(22, \"pre\")(23, \"code\", 9);\n            i0.ɵɵtext(24, \"\\n        SELECT ?s ?p ?o \");\n            i0.ɵɵelement(25, \"br\");\n            i0.ɵɵtext(26, \"\\n        WHERE { \");\n            i0.ɵɵelement(27, \"br\");\n            i0.ɵɵtext(28, \"\\n        ?s ?p ?o . \");\n            i0.ɵɵelement(29, \"br\");\n            i0.ɵɵtext(30, \"\\n        }\\n      \");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(31, \"\\n      \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(32, \"div\", 4)(33, \"p\");\n            i0.ɵɵtext(34, \" In this query, ?s, ?p, and ?o represent the subject, predicate, and object of every triple in the dataset. When this query runs, it returns a list of all the triples, essentially giving you a snapshot of the entire dataset. It\\u2019s a powerful way to start exploring your data and understanding the structure of the information you're working with. \");\n            i0.ɵɵelement(35, \"br\")(36, \"br\");\n            i0.ɵɵtext(37, \" In the following sections of this guideline, we will explain the basics of writing a SPARQL query. We will use a simple scenario of searching the DBpedia database for information about movies. \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(38, \"div\", 4)(39, \"h3\", 10);\n            i0.ɵɵtext(40, \"SELECT, WHERE and LIMIT\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(41, \"p\");\n            i0.ɵɵtext(42, \" In SPARQL, the \");\n            i0.ɵɵelementStart(43, \"em\", 11);\n            i0.ɵɵtext(44, \"SELECT\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(45, \" clause is where you define the specific pieces of data you want to pull from your dataset. Think of it as telling the query exactly what information you're looking for and inorder to actually find the data you're interested in, you'll use the \");\n            i0.ɵɵelementStart(46, \"em\", 11);\n            i0.ɵɵtext(47, \"WHERE\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(48, \" clause. This is where you set the conditions, or patterns, that your data needs to match. It's like giving your query a set of instructions: \\\"Find me movies, but only those that match these specific criteria.\\\" The following code snippet shows a query to retrieve a list of movies and their titles from DBpedia database. \");\n            i0.ɵɵelement(49, \"br\");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(50, \"div\", 7);\n            i0.ɵɵelement(51, \"div\", 8);\n            i0.ɵɵelementStart(52, \"pre\")(53, \"code\", 9);\n            i0.ɵɵtext(54, \"\\n        SELECT ?movie ?title \");\n            i0.ɵɵelement(55, \"br\");\n            i0.ɵɵtext(56, \"\\n        WHERE {\\n         ?movie a <http://dbpedia.org/ontology/Film> ;\\n        <http://xmlns.com/foaf/0.1/name> ?title . \\n         }\\n        LIMIT 10\\n    \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(57, \"div\", 4)(58, \"p\");\n            i0.ɵɵtext(59, \" In the above example, we are using the keyword \");\n            i0.ɵɵelementStart(60, \"em\", 11);\n            i0.ɵɵtext(61, \"SELECT\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(62, \" to specify which variables we want to retrieve the movie itself (?movie) and its title (?title). \");\n            i0.ɵɵelement(63, \"br\")(64, \"br\");\n            i0.ɵɵtext(65, \" The keyword \");\n            i0.ɵɵelementStart(66, \"em\", 11);\n            i0.ɵɵtext(67, \"WHERE\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(68, \" is used to specify the conditions for matching data. Here, it specifies that: \");\n            i0.ɵɵelementStart(69, \"mat-list\")(70, \"mat-list-item\")(71, \"p\");\n            i0.ɵɵtext(72, \" 1. `?movie` should be an instance of \");\n            i0.ɵɵelementStart(73, \"a\", 12);\n            i0.ɵɵtext(74, \"http://dbpedia.org/ontology/Film\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(75, \", which is a DBpedia ontology class that represents a movie. \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(76, \"mat-list-item\")(77, \"p\");\n            i0.ɵɵtext(78, \" 2. `?movie` should have a property called `foaf:name`, which holds the movie\\u2019s title. \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(79, \"em\", 11);\n            i0.ɵɵtext(80, \"LIMIT\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(81, \" keyword is used to truncate the list of returned data and keep only the first 10 results. This is very handy when you are dealing with a large dataset but you are only interested in a sample pool. By setting a limit, you can easily achieve this. \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(82, \"div\", 4)(83, \"p\");\n            i0.ɵɵtext(84, \" We can also retrieve additional properties, as long as those properties are present in the ontology class, by binding more variables. Below is a code snippet to retrieve the runtime and release date, in addition to the name of each movie. \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(85, \"div\", 7);\n            i0.ɵɵelement(86, \"div\", 8);\n            i0.ɵɵelementStart(87, \"pre\")(88, \"code\", 9);\n            i0.ɵɵtext(89, \"\\n        SELECT ?movie ?name ?runtime ?releaseDate \");\n            i0.ɵɵelement(90, \"br\");\n            i0.ɵɵtext(91, \"\\n        WHERE {\\n          ?movie a <http://dbpedia.org/ontology/Film> ;\\n                 <http://xmlns.com/foaf/0.1/name> ?name ;\\n                 <http://dbpedia.org/ontology/runtime> ?runtime ;\\n                 <http://dbpedia.org/ontology/releaseDate> ?releaseDate . \\n        }\\n        LIMIT 10\\n    \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(92, \"div\", 4)(93, \"h3\", 5);\n            i0.ɵɵtext(94, \" Internationalized Resource Identifiers - IRIs \");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(95, \"p\");\n            i0.ɵɵtext(96, \" In SPARQL queries, URLs (Uniform Resource Locators) and IRIs (Internationalized Resource Identifiers) are important for identifying resources and properties. They serve as unique identifiers that allow you to precisely specify the data you want to query. Each URL or IRI points to a specific resource or property within a dataset - DBpedia, for example, has its own set of resources and properties. Using IRIs eliminates confusion about what you\\u2019re querying and provides clear references that are understood universally. \");\n            i0.ɵɵelement(97, \"br\")(98, \"br\");\n            i0.ɵɵtext(99, \" For instance, in our previous query example: \");\n            i0.ɵɵelementStart(100, \"mat-list\")(101, \"mat-list-item\")(102, \"p\");\n            i0.ɵɵtext(103, \" -> The URL \");\n            i0.ɵɵelementStart(104, \"a\", 13);\n            i0.ɵɵtext(105, \" `http://dbpedia.org/ontology/Film` \");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(106, \" identifies the Film class within the DBpedia ontology, specifying that we are interested in resources categorized as movies. \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(107, \"mat-list-item\")(108, \"p\");\n            i0.ɵɵtext(109, \" -> The URL \");\n            i0.ɵɵelementStart(110, \"a\", 14);\n            i0.ɵɵtext(111, \"`http://xmlns.com/foaf/0.1/name`\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(112, \" identifies the name property, which holds the title of each movie. \");\n            i0.ɵɵelementEnd()()()();\n            i0.ɵɵelementStart(113, \"div\", 4)(114, \"p\");\n            i0.ɵɵtext(115, \" These URLs (or IRIs) are essential because they uniquely define what we mean by \\\"Film\\\" and \\\"name\\\" in the context of the DBpedia dataset. \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(116, \"div\", 7);\n            i0.ɵɵelement(117, \"div\", 8);\n            i0.ɵɵelementStart(118, \"pre\")(119, \"code\", 9);\n            i0.ɵɵtext(120, \"\\n        PREFIX dbo: <http://dbpedia.org/ontology/> \");\n            i0.ɵɵelement(121, \"br\");\n            i0.ɵɵtext(122, \" \\n        PREFIX dbp: <http://dbpedia.org/property> \");\n            i0.ɵɵelement(123, \"br\");\n            i0.ɵɵtext(124, \"\\n        SELECT ?movie ?name ?releaseDate \");\n            i0.ɵɵelement(125, \"br\");\n            i0.ɵɵtext(126, \"\\n        WHERE { \\n        ?movie a dbo:Film ; \\n        dbp:name ?name ; \\n        dbo:releaseDate\\n        ?releaseDate .\\n         } \\n        LIMIT 10\\n      \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(127, \"div\", 4)(128, \"h3\", 10);\n            i0.ɵɵtext(129, \"Prefixes\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(130, \"p\");\n            i0.ɵɵtext(131, \" As you start writing SPARQL queries, you\\u2019ll notice that many of the resources and properties have long, complex IRIs. Constantly typing out these lengthy IRIs can be cumbersome. That\\u2019s where prefixes come in. \");\n            i0.ɵɵelement(132, \"br\")(133, \"br\");\n            i0.ɵɵtext(134, \" Prefixes are shorthand notations that allow you to reference long IRIs with shorter, more readable terms. By defining a prefix at the beginning of your SPARQL query, you create an alias for a specific IRI. This approach helps in making your queries cleaner and easier to read. To create a prefix, you need to identify the resource IRI that you will use. Specific properties from that IRI are referenced using the alias you define, so you only need to provide the part of the resource path after the prefix. The syntax is the keyword PREFIX, followed by an alias name, a colon, and the resource URL. \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(135, \"div\", 7)(136, \"div\", 8)(137, \"a\")(138, \"mat-icon\");\n            i0.ɵɵtext(139, \"content_copy\");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(140, \"pre\")(141, \"code\", 9);\n            i0.ɵɵtext(142, \"\\n          PREFIX dbo: <http://dbpedia.org/ontology/>\\n        \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(143, \"div\", 4)(144, \"p\");\n            i0.ɵɵtext(145, \" Now let\\u2019s take the previous example where we queried for the name, release date, and runtime of movies, and define prefixes to tidy up the query: \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(146, \"div\", 7)(147, \"div\", 8)(148, \"a\")(149, \"mat-icon\");\n            i0.ɵɵtext(150, \"content_copy\");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(151, \"a\")(152, \"mat-icon\");\n            i0.ɵɵtext(153, \"open_in_new\");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(154, \"pre\")(155, \"code\", 9);\n            i0.ɵɵtext(156, \"\\n          PREFIX dbo: <http://dbpedia.org/ontology/> \");\n            i0.ɵɵelement(157, \"br\");\n            i0.ɵɵtext(158, \"\\n          PREFIX foaf: <http://xmlns.com/foaf/0.1/> \");\n            i0.ɵɵelement(159, \"br\");\n            i0.ɵɵtext(160, \"\\n          SELECT ?movie ?name ?runtime ?releaseDate \");\n            i0.ɵɵelement(161, \"br\");\n            i0.ɵɵtext(162, \"\\n          WHERE {\\n            ?movie a dbo:Film ; \");\n            i0.ɵɵelement(163, \"br\");\n            i0.ɵɵtext(164, \"\\n                   foaf:name ?name ; \");\n            i0.ɵɵelement(165, \"br\");\n            i0.ɵɵtext(166, \"\\n                   dbo:runtime ?runtime ; \");\n            i0.ɵɵelement(167, \"br\");\n            i0.ɵɵtext(168, \"\\n                   dbo:releaseDate ?releaseDate . \");\n            i0.ɵɵelement(169, \"br\");\n            i0.ɵɵtext(170, \"\\n          }\\n          LIMIT 10\\n      \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(171, \"div\", 4)(172, \"h3\", 5);\n            i0.ɵɵtext(173, \"Filters\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(174, \"p\");\n            i0.ɵɵtext(175, \" In SPARQL queries, filters are used to refine and constrain the results based on specific conditions. They help in selecting only those data entries that meet certain criteria, narrowing down the dataset to only the most pertinent information. \");\n            i0.ɵɵelement(176, \"br\")(177, \"br\");\n            i0.ɵɵtext(178, \" Use filters when you need to enforce specific conditions on your data, such as retrieving only movies released after a certain year or only movies with a runtime longer than a specific duration. \");\n            i0.ɵɵelement(179, \"br\")(180, \"br\");\n            i0.ɵɵtext(181, \" Here\\u2019s an example of how you might use a FILTER in a SPARQL query to retrieve only movies released after 2000 and with a runtime of less than an hour and a half: \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(182, \"div\", 7);\n            i0.ɵɵelement(183, \"div\", 8);\n            i0.ɵɵelementStart(184, \"pre\")(185, \"code\", 9);\n            i0.ɵɵtext(186, \"\\n        PREFIX dbo: <http://dbpedia.org/ontology/> \");\n            i0.ɵɵelement(187, \"br\");\n            i0.ɵɵtext(188, \"\\n        PREFIX foaf: <http://xmlns.com/foaf/0.1/> \");\n            i0.ɵɵelement(189, \"br\")(190, \"br\");\n            i0.ɵɵtext(191, \"\\n        SELECT ?movie ?name ?releaseDate ?runtime \");\n            i0.ɵɵelement(192, \"br\");\n            i0.ɵɵtext(193, \"\\n        WHERE {\\n          ?movie a dbo:Film ; \");\n            i0.ɵɵelement(194, \"br\");\n            i0.ɵɵtext(195, \"\\n                 foaf:name ?name ; \");\n            i0.ɵɵelement(196, \"br\");\n            i0.ɵɵtext(197, \"\\n                 dbo:releaseDate ?releaseDate ; \");\n            i0.ɵɵelement(198, \"br\");\n            i0.ɵɵtext(199, \"\\n                 dbo:runtime ?runtime . \");\n            i0.ɵɵelement(200, \"br\");\n            i0.ɵɵtext(201, \"\\n          FILTER (YEAR(?releaseDate) > 2000 \\n                   && ?runtime < \\\"PT1H30M\\\"^^xsd:duration) \");\n            i0.ɵɵelement(202, \"br\");\n            i0.ɵɵtext(203, \"\\n        }\\n        LIMIT 10\\n    \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(204, \"div\", 4)(205, \"p\");\n            i0.ɵɵtext(206, \" The \");\n            i0.ɵɵelementStart(207, \"em\", 11);\n            i0.ɵɵtext(208, \"WHERE\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(209, \" clause is used to define the pattern of triples that your query will match in the dataset. It specifies the conditions for the data relationships and structure. On the otherhand, The \");\n            i0.ɵɵelementStart(210, \"em\", 11);\n            i0.ɵɵtext(211, \"FILTER\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(212, \" clause is applied after the WHERE clause to impose additional constraints on the results. It refines the results by evaluating expressions based on the variables returned by the WHERE clause. \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(213, \"div\", 4)(214, \"h3\", 5);\n            i0.ɵɵtext(215, \"Order By\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(216, \"p\")(217, \"em\", 15);\n            i0.ɵɵtext(218, \"ORDER BY\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵtext(219, \" is a straightforward keyword in SPARQL that helps to sort query results based on specified conditions. In our example, let's say we want to order the movies by their release date in descending order, so the most recent movies appear at the top. \");\n            i0.ɵɵelement(220, \"br\")(221, \"br\");\n            i0.ɵɵtext(222, \" Here's how you would modify the query to include the em.highlight-language-clauseORDER BY clause:\");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(223, \"div\", 7);\n            i0.ɵɵelement(224, \"div\", 8);\n            i0.ɵɵelementStart(225, \"pre\")(226, \"code\", 9);\n            i0.ɵɵtext(227, \"\\n        PREFIX dbo: <http://dbpedia.org/ontology/> \");\n            i0.ɵɵelement(228, \"br\");\n            i0.ɵɵtext(229, \"\\n        PREFIX foaf: <http://xmlns.com/foaf/0.1/> \");\n            i0.ɵɵelement(230, \"br\");\n            i0.ɵɵtext(231, \"\\n        SELECT ?movie ?name ?releaseDate \");\n            i0.ɵɵelement(232, \"br\");\n            i0.ɵɵtext(233, \"\\n        WHERE {\\n          ?movie a dbo:Film ; \");\n            i0.ɵɵelement(234, \"br\");\n            i0.ɵɵtext(235, \"\\n                 foaf:name ?name ; \");\n            i0.ɵɵelement(236, \"br\");\n            i0.ɵɵtext(237, \"\\n                 dbo:releaseDate ?releaseDate . \");\n            i0.ɵɵelement(238, \"br\");\n            i0.ɵɵtext(239, \"\\n        }\\n        ORDER BY DESC(?releaseDate) \");\n            i0.ɵɵelement(240, \"br\");\n            i0.ɵɵtext(241, \"\\n        LIMIT 10\\n    \");\n            i0.ɵɵelementEnd()()();\n            i0.ɵɵelementStart(242, \"div\", 16)(243, \"p\");\n            i0.ɵɵtext(244, \" By understanding the basics of querying with SPARQL you now have the foundation needed to explore and interact with RDF data effectively. \");\n            i0.ɵɵelement(245, \"br\")(246, \"br\");\n            i0.ɵɵtext(247, \" SPARQL provides powerful tools to retrieve and manipulate data from diverse datasets, making it an invaluable skill for working with the Semantic Web. As you continue to practice and experiment with different queries, you\\u2019ll discover even more advanced techniques and functionalities. \");\n            i0.ɵɵelement(248, \"br\")(249, \"br\");\n            i0.ɵɵtext(250, \" If you\\u2019re eager to dive deeper, we\\u2019ve compiled additional resources for further reading and exploration. Happy querying! \");\n            i0.ɵɵelementEnd()();\n            i0.ɵɵelementStart(251, \"div\", 17)(252, \"h3\", 5);\n            i0.ɵɵtext(253, \"Additional Resources\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(254, \"p\");\n            i0.ɵɵtext(255, \"For further reading, below are some resources to get you started:\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(256, \"mat-list\")(257, \"mat-list-item\");\n            i0.ɵɵtext(258, \"-> DuCharme, B. (2013). Learning SPARQL: Querying and updating with SPARQL 1.1. O'Reilly Media. \");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(259, \"mat-list-item\");\n            i0.ɵɵtext(260, \"-> W3C Recommendation 21 March 2013https://www.w3.org/TR/sparql11-query/ \");\n            i0.ɵɵelementEnd()()()();\n            i0.ɵɵelementStart(261, \"div\", 18);\n            i0.ɵɵelement(262, \"hr\");\n            i0.ɵɵelementStart(263, \"p\", 19);\n            i0.ɵɵtext(264, \"Author: Meti Bayissa\");\n            i0.ɵɵelementEnd();\n            i0.ɵɵelementStart(265, \"p\", 20);\n            i0.ɵɵtext(266, \"August, 2024\");\n            i0.ɵɵelementEnd()()();\n          }\n        },\n        dependencies: [i2.MatList, i2.MatListItem, i3.MatIcon],\n        styles: [\".documentation-content-container[_ngcontent-%COMP%]{margin:7% 10%}.documentation-content-container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{text-align:center;font-size:2.5rem;font-weight:700;color:#073144;text-transform:capitalize}.documentation-content-container[_ngcontent-%COMP%]   .sub-section-title[_ngcontent-%COMP%]{font-size:1.4rem;text-transform:capitalize;margin-bottom:1rem}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .paragraph[_ngcontent-%COMP%]{text-align:justify;line-height:25px;font-size:1.1rem}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .paragraph[_ngcontent-%COMP%]   .highlight-language-keyword[_ngcontent-%COMP%]{color:#e80b76;font-weight:500}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .code-snippet-container[_ngcontent-%COMP%]{padding:0 1.5rem;margin:2% 5%}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .code-snippet-header[_ngcontent-%COMP%]{background-color:#eecd62aa;display:flex;height:1.2rem;justify-content:flex-end;gap:15px;color:#0c0900;padding:.5rem}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .language-sparql[_ngcontent-%COMP%]{margin:0!important;padding:0!important}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .closing-remarks[_ngcontent-%COMP%]{margin-top:7%}.documentation-content-container[_ngcontent-%COMP%]   .footer[_ngcontent-%COMP%]{font-style:italic;color:gray;margin-top:9%;text-align:center}.documentation-content-container[_ngcontent-%COMP%]   mat-list-item[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{word-wrap:break-word;white-space:pre-wrap}@media (max-width: 768px){.documentation-content-container[_ngcontent-%COMP%]{margin:5% 8%}.documentation-content-container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{font-size:2rem}.documentation-content-container[_ngcontent-%COMP%]   .sub-section-title[_ngcontent-%COMP%]{font-size:1.3rem}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .paragraph[_ngcontent-%COMP%]{font-size:1rem;line-height:22px}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .code-snippet-container[_ngcontent-%COMP%]{margin:2%}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .code-snippet-header[_ngcontent-%COMP%]{height:auto;padding:.3rem}.documentation-content-container[_ngcontent-%COMP%]   .footer[_ngcontent-%COMP%]{margin-top:7%}}@media (max-width: 480px){.documentation-content-container[_ngcontent-%COMP%]{margin:5%}.documentation-content-container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{font-size:1.8rem}.documentation-content-container[_ngcontent-%COMP%]   .sub-section-title[_ngcontent-%COMP%]{font-size:1.2rem}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .paragraph[_ngcontent-%COMP%]{font-size:.95rem;line-height:20px}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .code-snippet-container[_ngcontent-%COMP%]{margin:2% 1%;padding:0 1rem}.documentation-content-container[_ngcontent-%COMP%]   .documentation-content[_ngcontent-%COMP%]   .code-snippet-header[_ngcontent-%COMP%]{font-size:.9rem;padding:.2rem}.documentation-content-container[_ngcontent-%COMP%]   .footer[_ngcontent-%COMP%]{font-size:.9rem;margin-top:6%}}\"]\n      });\n    }\n  }\n  return SparqlForBeginnersDocumentationComponent;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}